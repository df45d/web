

// wgsl implementation of FXAA
// Derived from FXAA White Paper NVIDIA

// The minimum amount of local contrast required to apply algorithm (1/3, 1/4, 1/8, 1/16)
const FXAA_EDGE_THRESHOLD = 0.125;

// Trims the algorithm from processing darks (1/32, 1/16, 1/12)
const FXAA_EDGE_THRESHOLD_MIN = 0.0625;

// Controls removal of sub-pixel aliasing (1/2, 1/3, 1/4, 1/8, 0)
const FXAA_SUBPIX_TRIM = 0.25;

// Insures fine detail is not completely removed (3/4, 7/8, 1)
const FXAA_SUBPIX_CAP = 0.75;

fn fxaaLuminance(color: vec3f) -> f32 {
    return color.g * (0.587 / 0.299) + color.r;
}

fn fxaa(coord: vec2i) -> vec3f {
    let colorN = textureLoad(prePass, coord + vec2i(0, -1), 0).rgb;
    let colorW = textureLoad(prePass, coord + vec2i(-1, 0), 0).rgb;
    let colorM = textureLoad(prePass, coord + vec2i(0, 0), 0).rgb;
    let colorE = textureLoad(prePass, coord + vec2i(1, 0), 0).rgb;
    let colorS = textureLoad(prePass, coord + vec2i(0, 1), 0).rgb;

    let lumaN = fxaaLuminance(colorN);
    let lumaW = fxaaLuminance(colorW);
    let lumaM = fxaaLuminance(colorM);
    let lumaE = fxaaLuminance(colorE);
    let lumaS = fxaaLuminance(colorS);

    // Local Contrast Check
    let rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
    let rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));

    let range = rangeMax - rangeMin;

    if (range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {
        return colorM;
    }

    // Sub-pixel Aliasing Test

    let lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;
    let rangeL = abs(lumaL - lumaM);
    var blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * (1 / (1 - FXAA_SUBPIX_TRIM));
    blendL = min(FXAA_SUBPIX_CAP, blendL);

    var colorL = colorN + colorW + colorM + colorE + colorS;
    let colorNW = textureLoad(prePass, coord + vec2i(-1,-1), 0).rgb;
    let colorNE = textureLoad(prePass, coord + vec2i( 1,-1), 0).rgb;
    let colorSW = textureLoad(prePass, coord + vec2i(-1, 1), 0).rgb;
    let colorSE = textureLoad(prePass, coord + vec2i( 1, 1), 0).rgb;
    colorL += (colorNW + colorNE + colorSW + colorSE);
    colorL *= vec3f(1 / 9, 0, 0); 

    let lumaNW = fxaaLuminance(colorNW);
    let lumaNE = fxaaLuminance(colorNE);
    let lumaSW = fxaaLuminance(colorSW);
    let lumaSE = fxaaLuminance(colorSE);

    // Vertical Edge Test
    let edgeVert =
        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +
        abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +
        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));
    let edgeHorz =
        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +
        abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +
        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));
    
    let horzSpan = edgeHorz >= edgeVert;

    if (horzSpan) {
        return vec3f(1, 0, 0);
    } else {
        return vec3f(0, 1, 0);
    }

    return vec3f(0, 0, 1);
}